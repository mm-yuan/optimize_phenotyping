function new_directions = getNewGeneration(directions,scores,mutation_sigma,fraction_elite,constrain,sq,best_dir,cutoff)

if nargin < 6, seed = 6; else seed = sq; end
if nargin < 6, sq = 1; end
if nargin < 7, best_dir = []; end
if nargin < 8, cutoff = 0.1; end
if sq==1, best_dir = []; else best_dir = best_dir(1:(sq-1),:); end

n_per_colony = size(directions,1);
dim = size(mutation_sigma,1);
n_elite = ceil(fraction_elite*n_per_colony);
n_offspring = n_per_colony - n_elite;
fitness = (scores-min(scores))./range(scores); % normalize in range 0-1 as weight, for randsample(population,k,true,weight);

if strcmp('sequential', constrain)   
    if sq == 1
        [~,idx_elite] = maxk(fitness,n_elite);
        elite_directions = directions(idx_elite,:);
        rng(6+seed); idx = randsample(1:n_per_colony,n_offspring,true,fitness);
        offspring_directions = mutateDirection(directions(idx,:),mutation_sigma,1,sq);
        new_directions = cat(1,elite_directions,offspring_directions);
    else   
        relmat = 1-pdist2(directions,best_dir,'cosine');
        avg_rel = mean(abs(relmat),2);
        idx_far = find(avg_rel < cutoff);
        if isempty(idx_far), disp('END (no far-away dir)'); end
        % from step2, find elite only in far-away directions    
        directions_far = directions(idx_far,:);
        fitness_far = fitness(idx_far);
        [~,idx_elite] = maxk(fitness_far,n_elite);
        elite_directions = directions_far(idx_elite,:); 
        n_elite_far = length(idx_elite);
        % only far-away dirs can reproduce
        offspring_directions = mutateDirection(directions_far,mutation_sigma,1,sq); 
        if length(idx_far) == 1, offspring_directions = reshape(offspring_directions,[1 dim]); end
        if  size(offspring_directions,1) > n_offspring
            rng(6+seed); idx = randsample(1:length(idx_far),n_offspring,true,fitness_far);
            offspring_directions = offspring_directions(idx,:);
        end
        new_directions = cat(1,elite_directions,offspring_directions);
        if  size(new_directions,1) < n_per_colony
            % rest generated by elite again -> elite can generate more than one offspring
            n_sibs = n_per_colony-size(new_directions,1);   
            elite_offspring_directions = mutateDirection(elite_directions,mutation_sigma,ceil(n_sibs/n_elite_far),sq);
            elite_offspring_directions = squeeze(reshape(elite_offspring_directions,[],ceil(n_sibs/n_elite_far)*n_elite_far,dim));
            rng(6+seed); idx = randsample(1:ceil(n_sibs/n_elite_far)*n_elite_far,n_sibs); 
            elite_offspring_directions = elite_offspring_directions(idx,:);
            new_directions = cat(1,new_directions,elite_offspring_directions);
        end   
    end
    
elseif strcmp('none', constrain) | strcmp('mismatch', constrain) % vectorized
    [n_per_colony,n_colony,dim] = size(directions);
    [~,idx_elite] = maxk(fitness,n_elite);

    new_directions = nan(n_per_colony,n_colony,dim);
    parfor i = 1:n_colony
        rng(6+seed+10*i); idx = randsample(1:n_per_colony,n_offspring,true,fitness(:,i));
        offspring_directions = mutateDirection(squeeze(directions(idx,i,:)),mutation_sigma,1,i);
        elite_directions = squeeze(directions(idx_elite(:,i),i,:));
        new_directions(:,i,:) = cat(1,elite_directions,offspring_directions);
    end

elseif strcmp('minimize', constrain) 
    [n_per_colony,n_colony,dim] = size(directions);
    [~,idx_elite] = mink(fitness,n_elite);
    fitness_r = 1 - fitness; % sampling weight reverse 

    new_directions = nan(n_per_colony,n_colony,dim);
    parfor i = 1:n_colony
        rng(6+seed+10*i); idx = randsample(1:n_per_colony,n_offspring,true,fitness_r(:,i));
        offspring_directions = mutateDirection(squeeze(directions(idx,i,:)),mutation_sigma,1,i);
        elite_directions = squeeze(directions(idx_elite(:,i),i,:));
        new_directions(:,i,:) = cat(1,elite_directions,offspring_directions);
    end

end


end





